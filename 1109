mock表示这个api返回的数据是假的  仅作测试用
server表示需要启动这个服务

契约测试：
工具的约定

-------------------------------------------------------------------------------------------------------------
enumerate() 函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。


>>>seasons = ['Spring', 'Summer', 'Fall', 'Winter']
>>> list(enumerate(seasons))
[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]
>>> list(enumerate(seasons, start=1))       # 下标从 1 开始
[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]



QPS    ,CPU 了解
中级：自动化
高级：工具开发

----------------------------------------------
输入框：测试思路【思考框架】
----------------------------------------------
功能性； 常规可输入的内容，如 字符串，数字 ，特殊字符，转义字符
        非常规的，html标签，css ， JavaScript代码，url，tag（div等标签；定义高度宽度 ，id ，classname。。。
        输入内容的边界；空字符，超长文本，边界值+1，边界值-1
        
兼容性；  用户分布，产品品牌，分辨率，topN的机型

稳定性；  在某一压力下，搜索，结果可以正常返回
          多次查询，返回的内容相对稳定
          
性能；  QPS  Query Per Second,每秒能处理的请求数
        从点击开始到页面完全加载，平均耗时时间
        加载的页面大小，资源，（JS  ,CSS文件）的数量
        
安全；  SQL注入，JS注入  

接口；  查询接口正确性
        接口对一些异常情况的容错处理
        查询接口在非浏览器环境的处理情况

线上监控；保证线上服务质量，建立实施监控
          监控，及时发现异常情况，降低对用户的影响

自动化；Selenium  UI自动化
        例行回归验证，提高效率
        Ios ----  WDA
        Android --- uiautomator --- appium
        
 ====================================================================================
 表现得能力：
 技术能力；
 管理能力；
 学习能力；
 团队协助能力；
 --------------------------
 文案简洁，格式清晰
 
 工作内容：描述  【数量质量】
 学习能力：“保证项目质量和进度”
 
 
------------------------------------------------------------------------


移动端工具： monkey ，monkeyrunner ， ADB
移动端自动化框架： robotium ， appium ， uiautomator，selenium
平台： windows ，linux ， Android ， ios
服务端：loadrunner，jmeter
数据库：mysql可视化工具 ，navicat
-------------------------------------------------------------------------


工作效率？？成果？？
如何安排任务，如何提高测试效率
工作中的成果
如何团队间协调工作

--------------------------------------------------------------------------
问题得背后：【体现】
看人品，
看能力，
看态度
--------------------------------------------------------------------------

=====================================================================================
测试基本阶段： 单元测试
              集成测试
              系统测试
              验收测试
              
需求沟通 --- 制定测试方案 --- 设计测试用例 --- 准备测试环境 -- 测试执行 --- bug处理 -- 回归验收 --- 线上跟进 -- 




等价类   
边界值 
错误推测法   
正交表






测试理论；如何分层自动化测试：  UI自动化回归
                             接口自动化
                             单元测试-白盒测试
                             
                             
         如何降低自动化维护成本：UI自动化，针对不常见的页面
                               接口自动化，周期短，变动频繁
                               框架分层，用例与框架分离
         
               
         
         如何保证脚本有效性 ：保证定位有效性（封装），封装处理异常
                             保证流程有消息，封装独立方法
                             保证数据有效性，数据备份与恢复
                             
         常见的测试覆盖类型：语句覆盖
                            判定覆盖
                            条件覆盖
                            条件组合覆盖
                            路径覆盖
                            
                            
         B/S   和C/S区别
         
         
         安全性测试 包含：用户访问认证
                         传输数据加密
                         安全防护策略：安全日志，入侵检测，隔离防护，漏洞扫描
                         数据库备份与恢复
                         防病毒系统
                         SQL注入,JS注入
                         
         
         
         
         
         测试报告包含哪些内容：
                            测试背景说明
                            测试范围说明
                            测试环境说明
                            测试方法说明
                            测试结果结论
                            质量或风险评估
                            
                            
                            
                            
           Bug类型：
           bug：代码编写错误导致
           defect：缺陷，实现和需求不一致
           fault：由于环境系统问题引起的
         
         【4-2】
         

【【python常见的问题】】
说一下面向对象的概念：
                   面向对象编程，简称OOP,是一种程序设计思路
                   主要包括：类，继承，多态 ，实例，属性，方法
                   
                   
                   





什么是进程，线程，协程：
                      进程：独立数据空间，进程间不共享数据，系统调度
                      线程：执行程序的最小单元，进程内线程间共享资源，系统调度
                      协程：程序员调度，分解一个线程成为多个“微线程”
                      

#encoding:utf-8
#进程
# from multiprocessing import Process
#
# def foo(i):
#     print("this is Process",i)
# for i in range(5):
#     p = Process(target=foo,args=(i,))
#     p.start()


#线程
# import threading
#
# def show(i):
#     print('this is thread',i)
#
# for i in range(5):
#     t = threading.Thread(target=show,args=(i,))
#     t.start()



#协程
import gevent

def foo():
    print('start_foo')
    gevent.sleep(2)
    print("end_foo")
def bar():
    print("start_bar")
    gevent.sleep(0)
    print("end_foo")
# foo()
# bar()
gevent.joinall([
    gevent.spawn(foo),
    gevent.spawn(bar),
])


如何使用python实现socket编程：
                      socket又称套接字，应用程序通过套接字向网络发出请求
                      应用程序通过套接字应答网络请求
                      使主机间或一台计算机上的进程间可以通讯
                      
                      



什么是lambda函数：
                返回一系列连续增加的整数
                工作方式类似于 分片
                可以生成一个列表对象
                




tuple和list函数的区别：
                元组，不可修改
                列表，可修改




range函数的用法：
                注：python2 和python3里面的range函数不一样



字符串的拆分方法:
                string对象的split方法，不允许有多个分隔符
                函数re.split()，允许为分隔符指定多个正则模式
                
                
line = 'i am super man!'
print(line.split(" "))
import re
print(re.split("[m]",line))             

------------------------------------------


['i', 'am', 'super', 'man!']
['i a', ' super ', 'an!']
---------------------------------------------------------------------------------------





单引号，双引号，三引号的区别：
                        单引号，双引号，没有区别；三引号可以换行
                        
                        

*args和**kwargs什么作用：
                *args：可变的参数列表
                **kwargs：键值对参数列表



#arg
# def test_args(first,*args):
#     print(first)
#     for v in args:
#         print('args %s'%v)
# args = (2,3,4,5)
# print('--------')
# test_args(1,2,3,4,5)

#kwargs
def test_kwargs(first,*args,**kwargs):
    print(first)
    for v in args:
        print("args %s" %v)
    for k ,v in kwargs.items():
        print("kwargs",(k,v))
# args = (2,3,4,5)
# kwargs:k1=5,k2=6,k0=4
test_kwargs(1,2,3,4,5,k0=4,k1=5,k2=6)






python中pass语句的作用：
                       占位符，实现一个空函数
                       
                       
                       
                

re模块match和search方法的不同：
                        search，扫描整个字符串查找匹配
                        match，只在字符串的开始位置匹配
                    


import re

s1 = 'helloworld,helloworld'
w1 = 'hello'
w2 = 'world'
#search扫描整个字符串
print('1',re.search(w2,s1))
print('2',re.search(w2,s1).group())

#match只在字符串开始位置匹配
print('3',re.match(w2,s1))
print('4',re.match(w2,s1).group())


--------------------------------------------------------------------


1 <_sre.SRE_Match object; span=(5, 10), match='world'>
2 world
3 None
Traceback (most recent call last):
  File "D:/untitled/pyt crs/a12.py", line 32, in <module>
    print('4',re.match(w2,s1).group())
AttributeError: 'NoneType' object has no attribute 'group'

---------------------------------------------------------------------
                        
                        

解释一下WSGI和FastCGI的关系：
                CGI：公共网关接口（CommonGateway Interface）
                     HTTP服务器与机器上的程序进行交互的一种工具
                     程序须运行在网络服务器上，和语言无关
                
                WSGI：Python Web Server Gateway Interface
                      python应用程序和WEB服务器之间的一种接口
                      
                FastCGI: 像是一个常驻（long-live）型的CGI，它可以一直执行着
                
                
                
              

python是如何操作文件的：
                       打开文件
                       写入或读取数据
                       关闭文件
                       

模式	可做操作	  若文件不存在	是否覆盖
r	 只能读	     报错	              -
r+	 可读可写	    报错	             是
w	 只能写	     创建	              是
w+　	可读可写	   创建               是
a　　	只能写	   创建	            否，追加写
a+	可读可写	    创建	             否，追加写                       



#写文件
f = open('test.txt','wt')
f.write("hello world")
f.close()
#使用with，追加内容，不用关系文件关闭问题
with open('test.txt','at') as f:
    f.write("\nhello mook")
#读取文件
with open("test.txt",'rt') as f:
    print(f.read())
    
    
    
    

python的内存管理机制：
                        引用计数
                        垃圾回收
                        内存池
                        
                        
from  sys import getrefcount

a1 = 10000000
a2 = 10000000
del a1
del a2
print(id(a1))
print(id(a2))

#检验a和b是同一个东西
print(a1 is a2)

#获取a2的引用计数
print(getrefcount(a1))   






                        

dict的items和iteritems区别：
                items方法以列表方式返回，返回时没有特殊顺序
                iteritems 方法类似，但返回的是一个迭代器对象

【注】：在Python2.x中，

iteritems() 用于返回本身字典列表操作后的迭代



Python 3.x 里面，

iteritems() 方法已经废除了，而 items() 得到的结果是和 2.x 里面 viewitems() 一致的。在3.x 里 用 items()替换iteritems() ，可以用于 for 来循环遍历。
--------------------- 
作者：kukudehui 
来源：CSDN 
原文：https://blog.csdn.net/kukudehui/article/details/79896924 
版权声明：本文为博主原创文章，转载请附上博文链接！



五：基于python常问算法有哪些？？

排序：
       从小到大   sorted(list)
       从大到小   sorted(list,reverse=True)


冒泡 :
        比较相邻的元素，如果第一个比第二个大，就交换
        一轮遍历，每两个相邻元素，重复1，最大放队尾
        不包括已经排队尾的，重复2
        
-----------------------------------------------
#冒泡排序
def bubble_sort(lists):
    #获取数组的长度
    count = len(lists) -1
    #N个元素便利N次
    for index in range(count,0,-1):   #负数递减
        #第i个和第i+1个依次对比
        for sub_index in range(index):
            #大的元素冒上去
            if lists[sub_index] > lists[sub_index+1]:
                lists[sub_index],lists[sub_index+1] = lists[sub_index+1],lists[sub_index]
    return lists
alist = [0,10,88,19,9,1]
print(bubble_sort(alist))

-----------------------------------------------------





快排原理及代码实现：
        从列表中挑出一个元素，作为基准值key
        所有小于key的元素放左边，所有大于key的元素放在右边
        分别递归左侧列表，右侧列表  
        
        
 ---------------------------------------------------------------------------------------------------       
#【快速排序】【5-3】

def quick_sort(lists,left,right):
    if left > right:
        return lists
    #定义游标
    low = left
    high = right

    #取参考标志，最左边的元素
    key = lists[low]
    while low < high:
        #从最右侧向左，依次和标志元素对比，如果右侧的元素大于标志元素
        while low <high and lists[high] >= key:
            #右侧减1
            high -= 1
        #否则low赋high值
        lists[low] = lists[high]
        #从最左侧向右，依次和标志元素对比，如果左侧的元素小于标志元素
        while low < high and lists[low] <= key:
            #左侧+1
            low += 1
        #否则high赋low值
        lists[high] = lists[low]
    #最后给high位置赋值
    lists[high] = key
    #处理左侧元素
    quick_sort(lists,left,low -1)
    #处理右侧元素
    quick_sort(lists,low+1,right)
    return lists
alist = [0,10,88,19,9,1,7]
print(quick_sort(alist,0,6))

--------------------------------------------------------------------------------------------------------------
【5-4】
堆排序： 
        堆排序是指利用堆的数据结构设计的一种排序算法
        堆近似一个完全二叉树结构
        子节点的键值对小于（或者大于）它的父节点


#堆排序
def heap_sort(list):
    def sift_down(start,end):
        '''最大堆调整'''
        root = start
        print("root %d start %d end %d"%(root,start,end))
        while True:
            child = 2* root +1
            print("child index: %d"%child)
            #终止条件，孩子的索引值超过数组的最大长度
            if child > end:
                break
            print("lst child value:%d"%list[child])
            #确定最大的孩子节点的索引值
            if child +1 <= end and list[child] <list[child +1]:
                child += 1
                print("child+1 index: %d"%child)
            #孩子节点最大值和根节点交换
            if list[root] < list[child]:
                list[root],list[child] = list[child],list[root]
                print("list root %d "%list[root],"listchild %d"%list[child])
                root = child
                #print("root %d%root)
            else:
                break
    print("---------------创建最大堆----------------------------")
    #创建最大堆
    print(range((len(list) -2)//2,-1,-1))
    for start in range((len(list) -2)//2,-1,-1):
        print("--------loop start %d"%start)
        sift_down(start,len(list) -1)
        print(list)

    print('----------排序过程-------')
    #堆排序
    for end in range(len(list)-1,0,-1):
        #首位交换
        list[0],list[end] = list[end],list[0]
        #剩余重新排序
        sift_down(0,end-1)
        print(list)
alist = [70,60,12,40,30,8,10]
print((heap_sort(alist)))


        
           


二分查找：
        折半查找
        必须采用顺序存储结构
        必须按关键字大小有序排列
        【乱序 不能二分查找】
                




alist = [0,1,10,88,19,9,1]

def binary_search(arr,start,end,hkey):
    if start > end:
        return -1
    mid = start + (end - start)/2
    if arr[mid] >hkey:
        return binary_search(arr,start,mid-1,hkey)
    if arr[mid] < hkey:
        return binary_search(arr,mid+1 ,end,hkey)
    return mid
alist = sorted(alist)
print(alist)
print(binary_search(alist,0,6,9))


素数：
        

def is_prime(n):
    if n <=1:
        return False
    for i in range(2,n-1):
        if n % i == 0:
            return False
    return True
for i in range(0,100):
    if is_prime(i):
        print(i)
        

-------------------------
六  【linux】

        
 cd切换目录
ls -l 列出文件详细信息；ls -a 列出当前目录下所有文件
touch 创建文件
mkdir创建目录
echo 创建带有内容的文件
cat查看文件内容
grep 在文本文件中查找某个字符串
tree 显示目录结构
ln 创建软链
mv移动或重命名
wc 统计文本中的行数，字数，字符数
more ，less分页显示文本内容
head，tail显示文件头尾内容

---------------------------------------------
网络命令
curl利用url规则在命令行下工作的文件传输工具
netstat 显示网络状态信息
telnet登录远程手机（不安全，SSH替代
---------------------------------------------
系统命令
ping 测试网络
man 查看帮助
kill 杀死进程
top 动态显示当前耗费资源最多进程信息
ps 显示瞬间进程状态
df 查看磁盘大小    df -h带有单位显示磁盘信息


七 【计算机网络】
Open System Interconnection
OSI七层模型指的是哪些内容:
        【网络接口层】                
        物理层：建立，维护，断开物理连接
        数据链路层：逻辑连接，硬件地址连接，差错校验
        -----------------------------------------------------------------
        【IP层】
        网络层：逻辑地址寻址，不同网络之间的路径选择，IP
        -------------------------------------------------------------------
        【传输层】
        传输层：传输数据协议，TCP,UDP
        -------------------------------------------------------------------
        【应用层】
        会话层，建立、管理、终止会话，本地与远程主机的会话
        表示层：数据的标示，安全，压缩，JPEG,ASCII等
        应用层：与最终用户的接口，HTTP,HTTPS,SMTP等
        
        



http协议中get和post的区别：
                        功能差异
                        数据传输
                        安全性
                        
                        
                        

tcp和udp的区别：
                    TCP                      UDP
      是否连接       面向连接                 面向非连接
      传输可靠性     可靠的                   不可靠的
      应用场合       传输量大的数据            少量数据
      速度           慢                       快


tcp连接三次握手具体过程：
客户端             -------------------------               服务器

                        


socket建立连接的过程：
                服务器建立监听：socket，bind，listen
                客户端发送请求，connect，send
                连接确认，accept，response
                
                        


进程，线程区别：
                进程：独立数据空间，进程间不共享数据，系统调度
                线程：执行程序的最小单元，进程内线程间共享资源，系统调度
                一个进程可以有多个线程，多个线程也可以并发执行
       
        



进程都有哪些状态：
                就绪状态 ：已获除处理机以外所需资源，等待分配处理机资源
                运行状态：占用处理机资源运行，此状态进程数 <= CPU数
                阻塞状态：进程等待某种条件，在条件满足之前无法执行
                
                




进程同步与互斥的区别：
                互斥：
                某一资源同时只允许一个访问者对其进行访问
                具有唯一性和排他性
                互斥无法限制访问者对资源的访问顺序，即访问是无序的
                
                同步：
                基于互斥，经其它机制实现访问者对资源的有序访问
                大多数情况下，同步已经实现了互斥，写入资源是互斥的
                少数情况下，可以允许多个访问者同时访问资源


进程中的通信都包括哪些：
                        管道：半双工通信方式，数据单项流动，父子进程间
                        命名管道：半双工通信方式，无亲缘关系进程间通信
                        信号量：是计数器，锁机制，控制多进程对资源访问
                        消息队列：消息链接，存放在内核中由消息队列标识符标识
                        信号：比较复杂的通信方式，通知进程某个事件已经发生
                        共享内存：映射一段能被多个进程可访问的内存
                        




进程中的调度算法都有哪些：
                        先来先服务（FCFS,First Come First Service）
                        短作业优先（SJF,Shortest Process Next）
                        时间片轮转调度算法（RR,Round Robin）
                        高响应优先（HRRN,Highest Response Ratio Next）
                        优先权调度算法 
                        多级队列调度算法
                        
                        
                        
                        

死锁产生的原因：
                资源竞争
                进程推进顺序不当
                必要条件：互斥，不剥夺，请求与保持，环路等待
                预防死锁：破坏四个必要条件之一


页面的置换算法都有哪些
[8-4]

makefile的作用是什么

什么是虚拟、实存、共享内存


































































python常问算法

linux

计算机网络

操作系统

数据库

fiddler功能

安卓系统相关

adb相关

monkey相关





